<!doctype html><html lang=es>
<head>
<meta charset=utf-8>
<title>CeibOS. Parte 0</title>
<meta name=generator content="Hugo 0.92.1">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=/blog/css/styleshit.css type=text/css>
<link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/plugins/toolbar/prism-toolbar.min.css rel=stylesheet>
<link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/themes/prism-okaidia.min.css rel=stylesheet>
<link id=favicon rel=icon href=/favicon.png type=image/png sizes=16x16>
</head>
<body>
<div class=container>
<header>
<div class=header__logo>
<a href=https://aidea775.github.io/blog>
<div class=logo>
AIDEA775 en espa침ol
</div>
</a>
</div>
<nav class=menu>
<ul class=menu__inner>
<li class=button>
<a href=/blog/guides>Guias</a>
</li>
<li class=button>
<a href=/blog/notes>Notas</a>
</li>
<li class=button>
<a href=/blog/about>Sobre m칤</a>
</li>
</ul>
</nav>
</header>
<main role=main>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<h1>
<a href=https://aidea775.github.io/blog/posts/ceibos-parte-0/>CeibOS. Parte 0</a>
</h1>
<div class=meta>
<span class=key>published on</span>
<span class=val>
<time itemprop=datePublished datetime=2019-11-06>
November 06, 2019
</time>
</span>
<span class=key>in</span>
<span class=val>
<a href=https://aidea775.github.io/blog/posts>posts</a>
</span>
</div>
<section class=body itemprop=articleBody>
<h3 id=nunca-entend칤-los-_shortcuts_>Nunca entend칤 los <em>shortcuts</em></h3>
<h6 id=y-no-los-entend칤-porque-no-tienen-sentido>y no los entend칤 porque no tienen sentido:</h6>
<ul>
<li>Si estoy en un editor de texto, <code>Ctrl+c</code> copia el texto seleccionado.</li>
<li>Pero si estoy en una terminal, <code>Ctrl+c</code> termina el proceso que esta corriendo.</li>
<li>En cambio, <code>Ctrl+Shift+c</code> en una terminal copia el texto seleccionado.</li>
<li>Pero, <code>Ctrl+Shift+c</code> en Chromium abre el inspector.</li>
<li>&mldr;</li>
<li>En Visual Code, <code>Ctrl+x</code> corta la linea actual si no hay texto seleccionado.</li>
<li>Pero en cualquier otro lado, <code>Ctrl+x</code> no hace nada si no hay texto seleccionado.</li>
<li>&mldr; TODO m치s y conectar</li>
</ul>
<p>Es cierto hay otros que masomenos son est치ndar, como:</p>
<ul>
<li><code>Ctrl+t</code>/<code>Ctrl+Shift+t</code> para abrir/reabrir pesta침as.</li>
<li><code>Ctrl+w</code>/<code>Ctrl+q</code> para cerrar una pesta침a/ventana.</li>
<li><code>Ctrl+o</code>/<code>Ctrl+s</code> para abrir/guardar un archivo.</li>
<li><code>Alt+1..9</code> para cambiar de pesta침a.</li>
</ul>
<p>Pero despues hay atajos como:</p>
<ul>
<li><code>Ctrl+Alt+l</code> que bloquea la pantalla.</li>
<li><code>Ctrl+Alt+Der</code> en Visual Code parte el editor y pone la pesta침a a la derecha.</li>
<li><code>Ctrl+Alt+Print</code> saca un screenshot de la ventana y lo pega en el <em>clipboard</em>.</li>
<li><code>Ctrl+Alt+F1..F7</code> cambia a la tty1..tty7.</li>
<li><code>Ctrl+Alt+A</code> activa la ventana que requiere atenci칩n.</li>
<li><code>Ctrl+Alt+t</code> lanza una terminal.</li>
<li><code>Ctrl+Alt+-</code> en Visual Code va hacia atr치s.</li>
<li><code>Ctrl+Alt+Del</code> que mata al servidor X (!) (poweroff en GNOME).</li>
</ul>
<p>Entonces, 쯤u칠 relaci칩n hay entre los atajos que empiezan con <code>Ctrl+Alt</code>? Ninguna.</p>
<p>Algunos son del entorno grafico, otros del programa, y otros del sistema operativo.</p>
<p>Pero es que nunca hubo una gu칤a o un patr칩n, cada programa, cada <em>desktop environment</em>
y cada sistema operativo hace lo que quiere/puede.</p>
<p>Y hace falta eso, una gu칤a de dise침o que ponga reglas tipo:</p>
<ul>
<li>Locales a un proceso va con <code>Ctrl+algo</code></li>
<li>Si intervienen varios procesos va con <code>Meta+algo</code>.</li>
<li>Si se agrega <code>Shift</code> hace lo mismo, pero mas grande/fuerte/&ldquo;a lo bestia&rdquo;.</li>
<li>Si se agrega <code>Alt</code> hace lo mismo, pero de forma <em>alternativa</em>.</li>
<li>Si se agrega <code>?</code> hace justo lo opuesto.</li>
</ul>
<hr>
<p>Algunos axiomas:</p>
<ul>
<li>
<p>Los shortcuts no deben depender de la distribuci칩n del teclado, y deben ser pensados
en torno a su ubicaci칩n en el teclado, y no por la letra que representa en qwerty.</p>
</li>
<li>
<p>Shortcut no usado, es un shortcut desperdiciado.</p>
<p>Los shortcuts deben ser faciles de aprender y consultar en todo momento.
Por ejemplo, con <code>Mod+?</code> en donde sea que estemos, se despliega la ayuda
con un buscador donde poder filtrar los shortcuts disponibles, tanto los del
entorno grafico como los del programa que tenga foco en ese momento.</p>
</li>
<li>
<p>El sistema operativo nunca, nunca nunca, debe tomar decisiones sin el consentimiento
del usuario, y mucho menos hacer cosas a espaldas del usuario.</p>
<p>Me estoy refiriendo a las actualizaciones en segundo plano,
el usuario tiene el derecho de saber que el gestor de paquetes va a estar usando ancho de banda y ciclos de procesador.</p>
<p>La recolecci칩n de datos estar칤a bien, si se mantiene informado al usuario de los datos
que se enviaron o se est치n por enviar.</p>
</li>
<li>
<p>Toda acci칩n o decision del sistema operativo debe ser cancelable.</p>
<p>Toda accion debe reportarse por medio de notificaciones.
Desde conectarse a una red wifi, montar un dispositivo, apagar la pantalla, o buscar actualizaciones.
Y por ejemplo, con <code>Mod+Esc</code> se cancela la acci칩n que se est치 por hacer o que se acaba de hacer.</p>
</li>
<li>
<p>La pantalla nunca debe parpadear, ni durante el <em>booteo</em> ni cuando se conecta un monitor externo.</p>
<p>En serio, es molesto.</p>
</li>
<li>
<p>Las acciones rapidas deben cambiar muy poco el estado de la pantalla.</p>
<p>Lanzar una app debe ser algo rapido si se sabe que es lo que uno quiere.
Una forma de lograrlo es usando la busqueda, en menos de 3 letras uno encuentra la app que busca.
Los lanzadores de apps en full screen hacen que <strong>todo</strong> el contenido de la pantalla
cambie rapidamente dos veces, casi como un &ldquo;parpadeo&rdquo;.</p>
</li>
<li>
<p>El padding es bueno, pero tampoco la pavada.</p>
<p>Cada pixel es valioso para mostrar informaci칩n, pero tambien hay que separar una informaci칩n de otra.
El ruido visual es lo peor.</p>
</li>
<li>
<p>Hay que darle funciones especiales al trackpoint de las Thinkpads.</p>
<p>El pupito rojo es genial, pero no hay ningun entorno grafico que saque provecho de su ubicaci칩n.</p>
</li>
</ul>
<hr>
<p>El humano es muy bueno para ubicar objetos espacialmente,
incluso con los ojos cerrados vas a poder decir donde est치 tu celuar,
indicar en que direcci칩n est치 la puerta de salida,
y recordar donde dejaste la taza de caf칠.</p>
<p>Pero cuando tenes muchas ventanas/pesta침as abiertas,
no es tan facil saber donde esta esa ventana/pesta침a que necesitas,
<em>ni mucho menos cual es el camino para llegar a ella</em>.</p>
<blockquote>
<p>En los entornos gr치ficos normales, las ventanas son flotantes, pueden superponerse,
para cambiar entre ellas hay que recorrer una lista ordenada de alguna forma,
las ventanas est치n en un solo escritorio virtual, y estos se ubican en filas y columnas.</p>
</blockquote>
<blockquote>
<p>Luego existen los <em>tiling managers</em>, donde las ventanas son mosaicos, no se superponen,
se van acomodando ocupando toda la pantalla, no hace falta recorrer una lista para cambiar de
ventana ya que est치n todas a la vista.
los escritorios virtuales saben ser en una lista que puede ser dinamica (no tienen tama침o fijo).</p>
</blockquote>
<blockquote>
<p>Y no me enter칠 de otra cosa, hay diferentes tiling managers que permiten ordenar los mosaicos
de distintas formas, algunos permiten transformar un mosaico en una ventana flotante,
de igual forma hay entornos que permiten acomodar las ventanas flotantes en una suerte de mosaico.</p>
</blockquote>
<hr>
<p>Meta: Usar la pc sin tener que mirar la pantalla</p>
<p>Caso de uso: Cuando te conectas a un proyector, y este est치 detras tuyo.</p>
<p>Imagino lo siguente:</p>
<ul>
<li>
<p>Las ventanas son flotantes, pero no se pueden superponer,
sino que se van acomodando donde haya espacio.</p>
</li>
<li>
<p>Un escritorio es <em>scrolleable</em>.</p>
</li>
<li>
<p>Cuando no haya espacio para una ventana, el escritorio se &ldquo;expande&rdquo; hasta que la ventana entre.</p>
</li>
<li>
<p>El escritorio se puede scrollear o verticalmente u horizontalmente, pero no los dos a la vez.</p>
</li>
<li>
<p>Los escritorios se superponen, cada uno con su direcci칩n de scroll.</p>
</li>
<li>
<p>Las aplicaciones se pueden recorrer a trav칠s de una vista previa del escritorio o scrolleandolo.</p>
</li>
<li>
<p>Existen 3 escritorios: uno base, uno alterno, y uno superior (쯛ace falta m치s?).</p>
</li>
<li>
<p>Un escritorio se muestra a traves de todas las pantallas (un dibujo explicar칤a mejor esto).</p>
<p>Si la segunda pantalla est치 a la izquierda o derecha:</p>
<ul>
<li>Si el escritorio es scrolleable horizontalmente,
entonces el escritorio se muestra en las dos pantallas.</li>
<li>Si en cambio es scrolleable verticalmente,
entonces se muestra solamente en la pantalla principal.</li>
</ul>
</li>
<li>
<p>Se puede scrollear dem치s en caso que sea necesario (ver ejemplo de uso).</p>
</li>
<li>
<p>Los escritorios tienen cierta cantidad de filas y columnas que las ventanas pueden ocupar,
independientemente de la resoluci칩n, as칤 que pasar entre pantallas con resoluciones distintas
no deber칤a ser un problema.</p>
<p>Ya que si una app ocupaba 6 de 12 columnas en una pantalla 720p,
cuando se scrollee y pase a la pantalla secundaria 1080p,
se redimensionar치 para seguir ocupando la mitad horizontal.</p>
</li>
</ul>
<p>Ejemplo de caso de uso:</p>
<blockquote>
<p>TODO: Una animaci칩n ac치 seria mucho mas simple de entender.</p>
</blockquote>
<ol>
<li>Presentaci칩n de <em>slides</em> con un proyector.</li>
<li>Pantalla principal es la pantalla interna de la notebook.</li>
<li>Pantalla secundaria es el proyector, y est치 a la izquierda de la principal.</li>
<li>Las N slides se abren <strong>en orden</strong> en N ventanas
que se ubican en el escritorio base que es scrolleable horizontalmente.</li>
<li>En la pantalla principal se encuentra la primera slide, y el resto a la derecha.</li>
<li>Se hace scroll hacia la derecha, la primera slide ahora es visible por el proyector
y en la pantalla principal se encuentra la segunda slide.</li>
<li>En caso que se requiera hacer un cambio o chequear otra cosa,
se superpone el escritorio alterno, que se configura para ser scrolleable verticalmente,
y por lo tanto, solo se ve en la pantalla principal,
se puede scrollear sin afectar lo que se ve en el proyector.</li>
<li>Si se quiere mostrar algo por arriba de la presentaci칩n, por ejemplo una demo,
se superpone el escritorio superior, se lo configura en espejo,
de modo que el o los programas del escritorio se vean en ambas pantallas,
mientras que la presentaci칩n sigue por debajo justo donde la dejaron.</li>
<li>Para volver a la presentacion, simplemente se des-superpone los escritorios.</li>
</ol>
<p>Puede que no sea gran cosa, as칤 que ac치 van las:</p>
<h6 id=pros>PROS</h6>
<ul>
<li>En ningun momento se tuvo que hacer <code>Alt+Tab</code>, ni se vieron por el proyector las ventanas abiertas.</li>
<li>Todo esta espacialmente ubicado, y no hay comportamientos erraticos del tipo fullscreen en
la pantalla principal en vez del proyector.</li>
<li>Tampoco se tuvo que arrastar una ventana de una pantalla a otra.</li>
<li>No se sacrific칩 una pantalla al poner la segunda en modo espejo.</li>
<li>Las slides se controlan de la misma forma que se controla el entorno grafico,
nada de perder el foco y que de pronto la slide no avance.</li>
<li>Poder superponer la demo por arriba de la slide es algo que no se puede hacer
sin sacar el full screen de la presentacion, perdiendo el estado y rompiendo todo.</li>
</ul>
<hr>
<h1 id=wip>WIP</h1>
<p>Una de las cosas que m치s me gustaron al usar <code>i3wm</code>, es abrir varias terminales
(usaba <code>urxvt</code>) y usar el <em>Windows Manager</em> para acomodarlas en mosaico o pesta침as
seg칰n quisiera.</p>
<p>El entorno grafico debe permitir hacer eso, administrar muchas ventanas.
Por lo que programas no deber칤an tener su propia gestion de tabs,
eso deber칤a gestionarlo el propio compositor.</p>
<p>Las ventanas deben ser eficientes en mostrar una sola cosa conscisa.</p>
<p>Con esto lograr칤amos dar la sensacion de estar usando una sola aplicaci칩n que lo
tiene todo, y que con plugins (programas) podemos hacer mas cosas.</p>
<hr>
<p>El log del kernel al bootear es lindo, no hay porqu칠 esconderlo.
O tal vez ya lo he visto tantas veces que me acostumbr칠.</p>
<p>De todas formas, hay que agregarle m치s color.</p>
<hr>
<p>La gestion de ventanas debe ser escalable, tanto en tama침o de monitor, resoluci칩n,
y cantidad de ventanas abiertas, nada se puede perder de vista ni mezclarse.</p>
<p>Debe ser intuitivo manejar las ventanas usando un proyector
(o sea, sin tener que girar la cabeza para ver que es lo que hay en la segunda pantalla).</p>
<p>Saltar entre dos ventanas, por mas lejos que est칠n, debe ser trivial.</p>
<hr>
</section>
</article>
</main>
<footer>
<div class=copyright>
<span>游 2022 Powered by <a href=http://gohugo.io>Hugo</a>.</span>
<span>Made with 游뗿 by <a href=https://aidea775.github.io/blog>AIDEA775</a>.</span>
</div>
</footer>
<script src=https://aidea775.github.io/blog/assets/randfavicon.js defer async></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/components/prism-core.min.js defer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/plugins/autoloader/prism-autoloader.min.js defer></script>
<script src=https://aidea775.github.io/blog/assets/main.js defer></script>
</div>
</body>
</html>